function outputPulses = pulseMultiplicationA(initialStartTime,xOutputPulses,yOutputPulses,referenceTime)
%PULSEMULTIPLICATIONA Pulse train multiplication.
% pulseMultiplicationA.m : Multiply pulse trains generated by biphasic Integrate and Fire Analog to Pulse
% converter.
%
% Inputs:
% Initial conditions:
%     initialStartTime - start time of multiplication.
% Pulse trains:
%     xOutputPulses - pulse train of x(t)[column 1 - pulse timings, column
%     2 - threshold polarity]
%     yOutputPulses - pulse train of y(t)[column 1 - pulse timings, column
%     2 - threshold polarity]
%     referenceTime - interpulse interval of the identity pulse train.
%    
% Outputs:
% outputPulses - provides time of occurence of pulses (column 1) and its
% corresponding threshold polarity (column 2) after pulse multiplication
%
%   % Example:
%   xOutputPulses = apcTimeApprox(signalTime,xSignalAmplitude,pThreshold,nThreshold,refractoryPeriod,decayRate,timeResolution);
%   yOutputPulses = apcTimeApprox(signalTime,ySignalAmplitude,pThreshold,nThreshold,refractoryPeriod,decayRate,timeResolution);
%   initialStartTime=0;
%   referenceTime=pThreshold;
%   multOutputPulses = pulseMultiplicationA(initialStartTime,xOutputPulses,yOutputPulses,referenceTime);
% Last Updated : 1-31-2017



disp(sprintf(['\n' , '%s', '%d', '%s'], 'Pulse Multiplication - Status: Initializing'));
%% 1a. Initialize multiplication parameters
Nex=0; % excess area
en1_en=0; % time of excess area
%% 1b. Determine implementation time points for multiplication (every other pulse time)
implementationTime=unique(sort([initialStartTime;xOutputPulses(:,1); yOutputPulses(:,1)])).';
%% 1c. Set indexes and flags
implementationTimeIndex=1; % index number for implementation time points
pulseIndex=0; % index # for the output pulses
xOutOfBounds = false; % flag denoting change in polarity of amplitude
yOutOfBounds = false; % flag denoting "signalTimeIndex" exceeding length of input signal

%% 2. Multiplication
while(implementationTimeIndex < length(implementationTime));
    %% 2a. Boundary points: Implementation interval (a,b)
    a=implementationTime(implementationTimeIndex); % implementation interval: start time
    b=implementationTime(implementationTimeIndex+1); % implementation interval: end time
    %% 2b. Boundary points: Interval of pulse train x (Px1,Px2,PxPolarity)
    Px1Temp=find(xOutputPulses(:,1)<=a);
    if isempty(Px1Temp)
        Px1=initialStartTime;
    else
        Px1=xOutputPulses(max(Px1Temp),1);
    end
    
    Px2Temp=find(xOutputPulses(:,1)>=b);
    if isempty(Px2Temp)
        xOutOfBounds=true;
        disp(sprintf(['%s', '%d', '%s'], 'Multiplication complete (no more pulses on x): ',pulseIndex,' pulses generated'));
        break;
    else
        Px2=xOutputPulses(min(Px2Temp),1);
        PxPolarity=sign(xOutputPulses(min(Px2Temp),2));
    end
    
    %% 2c. Boundary points: Interval of pulse train y (Py1,Py2,PyPolarity)
    Py1Temp=find(yOutputPulses(:,1)<=a);
    if isempty(Py1Temp)
        Py1=initialStartTime;
    else
        Py1=yOutputPulses(max(Py1Temp),1);
    end
    
    Py2Temp=find(yOutputPulses(:,1)>=b);
    if isempty(Py2Temp)
        yOutOfBounds=true;
        disp(sprintf(['%s', '%d', '%s'], 'Multiplication complete (no more pulses on y): ',pulseIndex,' pulses generated'));
        break;
    else
        Py2=yOutputPulses(min(Py2Temp),1);
        PyPolarity=sign(yOutputPulses(min(Py2Temp),2));
    end
    %% 2d. Multiplication algorithm
    %% Step 1
    N=(PxPolarity*PyPolarity*(b-a)*referenceTime)/((Px2-Px1)*(Py2-Py1));
    %% Step 2
    if (N~=0 && abs(N+Nex)>=1)
        pn1_pn=(b-a)/abs(N);
        if pulseIndex==0
            pulseIndex=pulseIndex+1;
            outputPulses(pulseIndex,1)=(en1_en)+(pn1_pn)*abs(sign(N)-Nex);
            outputPulses(pulseIndex,2)=sign(N);
        else
            pulseIndex=pulseIndex+1;
            outputPulses(pulseIndex,1)=(en1_en)+outputPulses(pulseIndex-1,1)+(pn1_pn)*abs(sign(N)-Nex);
            outputPulses(pulseIndex,2)=sign(N);
        end
        
        % Update
        N=N-(sign(N)-Nex);
        Nex=0;
        en1_en=0;
        while (abs(N+Nex)>=1)
            pulseIndex=pulseIndex+1;
            outputPulses(pulseIndex,1)=(en1_en)+outputPulses(pulseIndex-1,1)+(pn1_pn)*abs(sign(N)-Nex);
            outputPulses(pulseIndex,2)=sign(N);
            N=N-(sign(N)-Nex);
        end
        Nex=N;
        en1_en=b-outputPulses(pulseIndex,1);
        
        
        %% Step 3
    elseif (N~=0 && abs(N+Nex)<1)
        % Update
        Nex=N+Nex;
        if (pulseIndex==0)
            en1_en=b;
        else
            en1_en=b-outputPulses(pulseIndex,1);
        end
        
        
        %% Step 4
    elseif (N==0)
        % Update
        if (pulseIndex==0)
            en1_en=b;
        else
            en1_en=b-outputPulses(pulseIndex,1);
        end
    end
    
    %% Step 5
    implementationTimeIndex=implementationTimeIndex+1;
    
end
%% 3. Assign threshold to output pulse polarity
threshold=abs(xOutputPulses(1,2));
outputPulses(:,2)=outputPulses(:,2)*threshold;