function outputPulses = pulseConvolutionA(xInitialStartTime,yInitialStartTime,xOutputPulses,yOutputPulses,referenceTime)
%PULSECONVOLUTIONA Pulse train convolution.
% pulseConvolutionA.m : Convolve pulse trains generated by biphasic Integrate and Fire Analog to Pulse
% converter.
%
% Inputs:
% Initial conditions:
%     xInitialStartTime - start time of x(t).
%     yInitialStartTime - start time of y(t).
% Pulse trains:
%     xOutputPulses - pulse train of x(t)[column 1 - pulse timings, column
%     2 - threshold polarity]
%     yOutputPulses - pulse train of y(t)[column 1 - pulse timings, column
%     2 - threshold polarity]
%     referenceTime - interpulse interval of the identity pulse train.
%    
% Outputs:
% outputPulses - provides time of occurence of pulses (column 1) and its
% corresponding threshold polarity (column 2) after pulse convolution
%
%   % Example:
%   xOutputPulses = apcTimeApprox(signalTime,xSignalAmplitude,pThreshold,nThreshold,refractoryPeriod,decayRate,timeResolution);
%   yOutputPulses = apcTimeApprox(signalTime,ySignalAmplitude,pThreshold,nThreshold,refractoryPeriod,decayRate,timeResolution);
%   referenceTime=pThreshold;
%   xInitialStartTime=0;
%   yInitialStartTime=0;
%   convOutputPulses = pulseConvolutionA(xInitialStartTime,yInitialStartTime,xOutputPulses,yOutputPulses,referenceTime);
% Last Updated : 1-31-2017

disp(sprintf(['\n' , '%s', '%d', '%s'], 'Pulse Convolution - Status: Initializing'));
%% 1a. Initialize start times and polarity
xOutputPulses=[xInitialStartTime xOutputPulses(1,2);xOutputPulses];
yOutputPulses=[yInitialStartTime yOutputPulses(1,2);yOutputPulses];

%% 1b. Initialize convolution parameters
Nex=0; % excess area
en1_en=0; % time of excess area

shift=0;
shiftPoint1=0;
shiftPoint2=0;
overlap=0;
overlapPoint1=0;
overlapPoint2=0;

%% 1c. Set indexes and flags

pulseIndex=0; % index # for the output pulses

%% 1d. Reverse Y
reversedYpulses=[yOutputPulses(:,1)*(-1) yOutputPulses(:,2)]; % reversed y pulses
%Note: Pulse timings of x increase from top to down; Pulse timings of reversed y decrease from top to down


%% 2. Convolution

while(~isempty(overlap) && ~isempty(shift))
    %% 2a. Determine Shift
    for i=1:length(reversedYpulses)
        distanceToAllXpulses=(xOutputPulses(:,1)-reversedYpulses(i,1));
        potentialNextPulses=find(distanceToAllXpulses>0);
        if isempty(potentialNextPulses)
            distanceToNextPulseOnXforY(i)=0;
        else
            distanceToNextPulseOnXforY(i)=min(distanceToAllXpulses(potentialNextPulses));
        end
    end
    
    availablePulsesOnX=find(distanceToNextPulseOnXforY>0);
    if isempty(availablePulsesOnX)
        disp('Shift is out of bounds')
        shift=[];
    else
        shift=min(distanceToNextPulseOnXforY(availablePulsesOnX));
        shiftPoint1=shiftPoint2;
        shiftPoint2=shiftPoint2+shift;
    end
    %% 2b. Shift Y
    reversedYpulses(:,1)=reversedYpulses(:,1)+shift;
    
    %% 2c. Determine Overlap
    xRange=[xOutputPulses(1,1) xOutputPulses(end,1)];
    reversedYrange=[reversedYpulses(end,1) reversedYpulses(1,1)];
    if xRange(1) < reversedYrange(1)
        lowRange = xRange;
        highRange = reversedYrange;
    else
        lowRange = reversedYrange;
        highRange = xRange;
    end
    
    result = lowRange(2) > highRange(1); % "result=true" indicates overlap, "result=false" indicates no overlap
    if result
        overlapPoint1=max(lowRange(1),highRange(1));
        overlapPoint2=min(lowRange(2),highRange(2));
        overlap=overlapPoint2-overlapPoint1;
    else
        overlap=[];
        disp('overlap is out of bounds')
    end
    if (~isempty(overlap) && ~isempty(shift))
        %% 2d. Determine a, b vectors
        overallImplementationTime=unique(sort([xOutputPulses(:,1); reversedYpulses(:,1)])).';
        relevantImplementationTimeIndex=find(overallImplementationTime>=overlapPoint1 & overallImplementationTime<=overlapPoint2);
        relevantImplementationTime=overallImplementationTime(relevantImplementationTimeIndex);
        
        aVector=relevantImplementationTime(1:end-1);
        bVector=relevantImplementationTime(2:end);
        %% 2e. Boundary points: Interval of pulse train x (Px1,Px2,PxPolarity)
        for i=1:length(aVector)
            Px1Temp=find(xOutputPulses(:,1)<=aVector(i));
            Px1(i)=xOutputPulses(max(Px1Temp),1);
            Px2Temp=find(xOutputPulses(:,1)>=bVector(i));
            Px2(i)=xOutputPulses(min(Px2Temp),1);
            PxPolarity(i)=sign(xOutputPulses(min(Px2Temp),2));
        end
        
        
        %% 2f. Boundary points: Interval of pulse train y (Py1,Py2,PyPolarity)
        for i=1:length(aVector)
            Py1Temp=find(reversedYpulses(:,1)<=aVector(i));
            Py1(i)=reversedYpulses(min(Py1Temp),1);  % we use min instead of max as Pulse timings of reversed y decrease from top to down
            Py2Temp=find(reversedYpulses(:,1)>=bVector(i));
            Py2(i)=reversedYpulses(max(Py2Temp),1); % we use max instead of min as Pulse timings of reversed y decrease from top to down
            PyPolarity(i)=sign(reversedYpulses(min(Py1Temp),2)); % we use Py1Temp instead of Py2Temp as Pulse timings of reversed y decrease from top to down
        end
        %% 2g. Calculate N's, p's
        for i=1:length(aVector)
            N(i)=(PxPolarity(i)*PyPolarity(i)*(bVector(i)-aVector(i))*referenceTime*shift)/((Px2(i)-Px1(i))*(Py2(i)-Py1(i)));
            pn1_pn(i)=((Px2(i)-Px1(i))*(Py2(i)-Py1(i)))/(referenceTime*overlap);
        end
        
        %% 2h. Convolution Algorithm
        cummulativeComponentAreas=cumsum(N)+Nex;
        potentialPulseAreas=find(abs(cummulativeComponentAreas)>=1);
        N_index=1;
        while(~isempty(potentialPulseAreas))
            target_index=min(potentialPulseAreas);
            requiredN=sign(cummulativeComponentAreas(target_index))-Nex;
            contributeOutputPulse=0;
            while (N_index<target_index)
                contributeOutputPulse=contributeOutputPulse+(abs(N(N_index)*pn1_pn(N_index)));
                %Update
                requiredN=requiredN-N(N_index);
                N(N_index)=0;
                N_index=N_index+1;
            end
            N_index=target_index;
            contributeOutputPulse=contributeOutputPulse+abs(requiredN*pn1_pn(N_index));
            if pulseIndex==0
                pulseIndex=pulseIndex+1;
                outputPulses(pulseIndex,1)=(en1_en)+contributeOutputPulse;
                outputPulses(pulseIndex,2)=sign(requiredN);
            else
                pulseIndex=pulseIndex+1;
                outputPulses(pulseIndex,1)=(en1_en)+outputPulses(pulseIndex-1,1)+contributeOutputPulse;
                outputPulses(pulseIndex,2)=sign(requiredN);
            end
            % Update
            N(N_index)=N(N_index)-requiredN;
            requiredN=0;
            Nex=0;
            en1_en=0;
            cummulativeComponentAreas=cumsum(N)+Nex;
            potentialPulseAreas=find(abs(cummulativeComponentAreas)>=1);
        end
        
        Nex=Nex+sum(N);
        if (pulseIndex==0)
            en1_en=shiftPoint2;
        else
            en1_en=shiftPoint2-outputPulses(pulseIndex,1);
        end
        %% 3. clear aVector, bVector,Px1,Px2,Py1,Py2,PxPolarity,PyPolarity,N,pn1_pn
        aVector=[];
        bVector=[];
        Px1=[];
        Px2=[];
        Py1=[];
        Py2=[];
        PxPolarity=[];
        PyPolarity=[];
        N=[];
        pn1_pn=[];
    end
    %disp(pulseIndex);
end

%% 4. Assign threshold to output pulse polarity
if (isempty(outputPulses))
    disp('Convolution complete: No pulses generated')
else
    disp(sprintf(['%s', '%d', '%s'], 'Convolution complete: ',pulseIndex,' pulses generated'));
    threshold=abs(xOutputPulses(1,2));
    outputPulses(:,2)=outputPulses(:,2)*threshold;
end